-- phpMyAdmin SQL Dump
-- version 4.8.5
-- https://www.phpmyadmin.net/
--
-- 主机： 127.0.0.1:3306
-- 生成日期： 2022-02-28 09:51:01
-- 服务器版本： 5.7.26
-- PHP 版本： 7.2.18

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- 数据库： `blog`
--

-- --------------------------------------------------------

--
-- 表的结构 `admin`
--

DROP TABLE IF EXISTS `admin`;
CREATE TABLE IF NOT EXISTS `admin` (
  `admin` varchar(30) CHARACTER SET latin1 NOT NULL COMMENT '管理员账号',
  `password` varchar(100) CHARACTER SET latin1 NOT NULL COMMENT '管理员密码',
  PRIMARY KEY (`admin`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `admin`
--

INSERT INTO `admin` (`admin`, `password`) VALUES
('liurunlin', 'e10adc3949ba59abbe56e057f20f883e');

-- --------------------------------------------------------

--
-- 表的结构 `api`
--

DROP TABLE IF EXISTS `api`;
CREATE TABLE IF NOT EXISTS `api` (
  `id` varchar(60) NOT NULL,
  `name` varchar(60) NOT NULL,
  `content` mediumtext NOT NULL,
  `time` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `id` (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `api`
--

INSERT INTO `api` (`id`, `name`, `content`, `time`) VALUES
('c3619ff70e01a240c74cd3ad4be4fd06', '测试', '<p><b><font size=\"4\">获取文章列表</font></b></p><p><b><font size=\"4\">接口地址：https://api.blogweb.cn/article/page/:page</font></b></p><p><b><font size=\"4\">返回格式：json<br/>请求方式：get<br/>请求示例：https://api.blogweb.cn/article/page/1</font></b></p><p><b><font size=\"4\">12333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333</font></b></p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th>名称</th><th>必填</th><th>类型</th><th>默认</th><th>说明</th></tr><tr><td>page</td><td>是</td><td>number</td><td>1</td><td>查询文章的页数</td></tr></tbody></table><p><br/></p><p>返回示例:</p><pre><code class=\"JSON\">{\n    <span class=\"hljs-string\">\"success\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"查询第1页的文章\"</span>,\n    <span class=\"hljs-string\">\"total\"</span>: <span class=\"hljs-number\">277</span>,\n    <span class=\"hljs-string\">\"data\"</span>: [\n        {\n            <span class=\"hljs-string\">\"type\"</span>: [\n                <span class=\"hljs-string\">\"Vue\"</span>,\n                <span class=\"hljs-string\">\"React\"</span>\n            ],\n            <span class=\"hljs-string\">\"article\"</span>: <span class=\"hljs-string\">\"测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容\"</span>,\n            <span class=\"hljs-string\">\"image\"</span>: <span class=\"hljs-literal\">false</span>,\n            <span class=\"hljs-string\">\"introduce\"</span>: <span class=\"hljs-string\">\"测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容测试填充内容\"</span>,\n            <span class=\"hljs-string\">\"id\"</span>: <span class=\"hljs-number\">289</span>,\n            <span class=\"hljs-string\">\"router\"</span>: <span class=\"hljs-string\">\"0.9046657241333818\"</span>,\n            <span class=\"hljs-string\">\"author\"</span>: <span class=\"hljs-string\">\"admin\"</span>,\n            <span class=\"hljs-string\">\"time\"</span>: <span class=\"hljs-string\">\"2021-11-25 13:20:35\"</span>,\n            <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"title289\"</span>,\n            <span class=\"hljs-string\">\"view_count\"</span>: <span class=\"hljs-number\">31</span>\n        },\n    ]\n}</code></pre>', '2016-07-08 10:27:22'),
('6ce00ac395b2dc308b120af085c6955f', '阿萨德萨达所大所', '<p>阿萨德萨达所大所</p>', '2021-12-16 23:43:02'),
('f040972ae1a5d5dc742e8b739822e3b6', '就落款加快了2', '<pre><code class=\"language-json\"><xmp>{\n  \"name\": \"client\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"cross-env NEXT_PUBLIC_ENV=development next dev -p 5678\",\n    \"build\": \"cross-env NEXT_PUBLIC_ENV=production next build\",\n    \"start\": \"cross-env NEXT_PUBLIC_ENV=production next start -p 5678\",\n    \"test_build\": \"cross-env NEXT_PUBLIC_ENV=development next build\",\n    \"test\": \"cross-env NEXT_PUBLIC_ENV=development next start -p 5678\",\n    \"analyze\": \"cross-env ANALYZE=true next build\",\n    \"analyze:server\": \"cross-env BUNDLE_ANALYZE=server next build\",\n    \"analyze:browser\": \"cross-env BUNDLE_ANALYZE=browser next build\"\n  },\n  \"dependencies\": {\n    \"antd\": \"^4.17.3\",\n    \"axios\": \"^0.24.0\",\n    \"classnames\": \"^2.3.1\",\n    \"next\": \"12.0.3\",\n    \"react\": \"17.0.2\",\n    \"react-dom\": \"17.0.2\",\n    \"react-infinite-scroll-component\": \"^6.1.0\",\n    \"wangeditor\": \"^4.7.10\"\n  },\n  \"devDependencies\": {\n    \"@next/bundle-analyzer\": \"^12.0.7\",\n    \"@types/node\": \"16.11.6\",\n    \"@types/react\": \"17.0.34\",\n    \"babel-plugin-import\": \"^1.13.3\",\n    \"babel-plugin-transform-remove-console\": \"^6.9.4\",\n    \"cross-env\": \"^7.0.3\",\n    \"node-sass\": \"^4.14.1\",\n    \"sass\": \"^1.43.4\",\n    \"styled-jsx-plugin-sass\": \"^1.0.0\",\n    \"typescript\": \"4.4.4\"\n  },\n  \"browserslist\": {\n    \"production\": [\n      \">0.2%\",\n      \"not dead\",\n      \"not op_mini all\"\n    ]\n  }\n}\n</xmp></code></pre>', '2022-02-19 23:25:41');

-- --------------------------------------------------------

--
-- 表的结构 `article`
--

DROP TABLE IF EXISTS `article`;
CREATE TABLE IF NOT EXISTS `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `router` varchar(60) NOT NULL,
  `author` varchar(60) NOT NULL,
  `type` varchar(60) NOT NULL,
  `article` mediumtext CHARACTER SET utf8mb4 NOT NULL,
  `time` datetime DEFAULT NULL,
  `title` varchar(200) NOT NULL,
  `view_count` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `router` (`router`)
) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `article`
--

INSERT INTO `article` (`id`, `router`, `author`, `type`, `article`, `time`, `title`, `view_count`) VALUES
(1, '1638719606363', 'admin', 'React,填坑', '<html><head></head><body><div><p>最近我在使用React+antd重写博客网站，在编写一个表单页面时遇到了如下报错：Warning: [antd: Upload] `value` is not a valid prop, do you mean `fileList`?</p><p><img src=\"1638719284810.jpg\"><br></p><p>在查找后解决方法如下：</p><p><br><img src=\"1638719315132.jpg\"><br>报错是因为Upload组件被嵌套在表单中造成的只需要在对应的Form.Item组件上添加 valuePropName=\"fileList\" 属性就可以了</p><p>但是虽然解决了初始化后报错问题，但是在上传图片时会出现新的报错，这是我们需要在添加一个属性：</p><p><img src=\"1639285540271.jpg\"></p><p><img src=\"1638721290817.jpg\"></p><p>getValueFromEvent={normFile}</p><p>主要就是处理上传时的状态使展示上传后的预览图片能顺利进行</p></div></body></html>', '2021-12-05 00:00:00', 'Warning: [antd: Upload] `value` is not a valid prop, do you mean `fileList`?', 26),
(2, '1627106874249', 'admin', 'TypeScript,填坑', '<html><head></head><body><div><p>在使用TypeScript开发项目时，在两个毫不相干的模块中定义相同变量tsLint会抛出：无法重新声明块范围变量“xxx”的错误</p><p><img src=\"1627106233101.jpg\"><br></p><p>在Google一番后找到了两种方法</p><ol><li><p>修改tsconfig.json一顿瞎改（亲测无用）</p></li><li><p>先分析原因可能是TS认为这些文件会被合并成一个文件，并没有会被认为是模块，那我们是不是可以去寻找一种方法让TS认为这两个毫不相干的文件是两个独立的模块</p></li></ol><p>我们只需要在文件的尾部加上<i>export&nbsp;{};</i></p><p><img src=\"1627106725102.jpg\"><br>就是这个样子，这样TS就会认为这些文件都是独立的模块了<br></p></div></body></html>', '2021-07-24 00:00:00', 'TypeScript解决无法重新声明块范围变量“XXX”问题', 13),
(3, 'cookiesessionjwt', 'admin', 'JavaScript,nodeJs,讲解', '<html><head></head><body><div><h3 data-we-empty-p=\"\" id=\"onqwo\">为什么使用权限验证？<br></h3><p>前后端分离很多接口会暴露在公网上，为了防止用户直接请求，或者被别有用心的人使用通常开发者会为登录后的用户签发一个token，客户端在发起请求的时候携带，后台确认请求者的身份判断是否执行<br></p><h3 id=\"1t57e\">常见的权限验证方式<br></h3><p>1.JWT (JsonWebToken)<br>2.Session、Cookie<br></p><h3 id=\"tp84u\">基于Cookie Session的验证方式<br></h3><p>1.用户输入用户名与密码，发送给服务器。<br>2.服务器验证用户名和密码，正确的就创建一个session会话，同时会把这个会话的ID保存到客户端浏览器中，因为保存的地方是浏览器的cookie，所以这种认证方式叫做基于cookie的认证方式。<br>3.后续的请求中，浏览器会发送会话ID到服务器，服务器上如果能找到对应的ID的会话，那么服务器就会返回需要的数据给浏览器。<br>4.当用户退出登录，会话会同时在客户端和服务器端被销毁<br></p><h3 id=\"g091p\"><a href=\"https://jwt.io/\" target=\"_blank\">JWT</a></h3><p>1.在用户登录成功后将签发的token返回，将验证信息存储在客户端<br>2.用户发起请求时携带token后端对token进行验证并执行对应的方法<br>3用户退出登录或者修改重要信息后在客户端销毁token<br><br></p><h3 id=\"lhdmg\">优缺点对比<br></h3><p>1.session默认储存在内存中（可以修改为保存 为文件或者Redis中），如果把代码部署在多台服务器上，session保存到了其中某一台服务器的内存中，JWT只要有秘钥就可以实现单点登录<br>2.JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权 限，一旦JWT签发，在有效期内将会一直有效,所以开发时经常设置专门的黑名单<br>3.推荐使用JWT非对称加密本站使用RS256配置公钥私钥来校验是否管理员登录<br></p></div></body></html>', '2021-10-12 00:00:00', 'Cookie-Session比较JWT', 29),
(4, 'axiosasyncawait', 'admin', 'AJAX,JavaScript', '<html><head></head><body><div><p>在最近的vue开发中ajax库选择了axios，需要根据回调函数的参数执行一个很长的代码块，执行函数加上axios参数代码量非常大不便于后期的优化和代码维护，于是我上网寻求axios异步的放法，被告知axios是promise返回值没有同步，如果代码量大可以尝试自行封装，于是研究了async和await</p><p>ES6Promise：</p><pre type=\"JavaScript\"><code><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1111</span>);\n    resolve(<span class=\"hljs-number\">2222</span>);\n}).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(value);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3333</span>;\n})</code></pre><p>生成一个异步函数如果执行成功就执行then中的函数如果失败就执行catch中的函数</p><p><b>async</b>就是将一个普通函数返回为promise，当然在学习async和await时你需要先了解promise的用法</p><pre type=\"JavaScript\"><code>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n        <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\'a\'</span>\n        }\n        test().then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n            <span class=\"hljs-built_in\">console</span>.log(res);\n        })\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre><p>test函数加上async会被转化为promise其中的return返回值就是then函数的参数</p><p><b>await</b>只能使用在promise中（包括async的返回函数）其用途和他的中文含义差不多：等待，意思是必须等到加await的函数结束promise才会继续执行</p><pre type=\"JavaScript\"><code><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'axios\'</span>;\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createType</span>(<span class=\"hljs-params\">getData</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> data;\n    <span class=\"hljs-keyword\">await</span> axios({\n        <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\"POST\"</span>,\n        <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">\'/create-type\'</span>,\n        <span class=\"hljs-attr\">data</span>: {\n            <span class=\"hljs-attr\">type</span>: getData.type\n        }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n        data = res.data;\n    })\n    <span class=\"hljs-keyword\">return</span> data;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> createType;</code></pre><ol><li>引入axios将</li><li>createType转化为promise<br></li><li>设置变量data准备作为返回值</li><li>为axios函数添加await等待axios完全执行完createType才会返回data变量</li><li>请求成功后将axios的请求值赋值给变量data</li><li>将整个函数导出方便复用</li></ol><p><b>项目导入函数</b></p><pre type=\"JavaScript\"><div class=\"code-title\">JavaScript</div><code><span class=\"hljs-keyword\">import</span> createHtml <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@/modules/function/createHtml\"</span>;\n<span class=\"hljs-keyword\">import</span> updataHtml <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@/modules/function/updataHtml.js\"</span>;\n<span class=\"hljs-keyword\">import</span> updataArticle <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@/modules/article/updata-article\"</span>;</code></pre><p><b>ajax函数使用</b></p><pre type=\"JavaScript\"><code>  createType({ <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-keyword\">type</span>.value }).then((res) =&gt; {\n\n\n  });</code></pre><p>!!:函数内对象为正常的函数传参</p></div></body></html>', '2021-03-19 00:00:00', '使用async和await封装axios', 17),
(5, 'createreactapp', 'admin', 'React', '<html><head></head><body><div><p>最近在学习react分享一下脚手架安装：</p><ol><li>进入指定文件夹</li><li>npm install create-<b>react</b>-app -g / yarn add create-react-app（先确认是否安装了node和npm）<br></li><li>create-react-app 项目名称 （ts:create-react-app 项目名称 --template&nbsp;typescript）</li><li>创建成功</li><li>安装插件 yarn add axios react-router&nbsp;</li><li>!!:对于css预编译选择sass的小伙伴需要注意，node-sass安装有网络问题和可能安装失败，推荐使用yarn（在node-sass 5.x版本得到解决但是node版本需要15或更高版本）</li></ol></div></body></html>', '2021-04-17 00:00:00', 'React脚手架安装', 29),
(6, 'expresscancelbodyparser', 'admin', 'nodeJs,填坑', '<html><head></head><body><div><p>在后端使用Express编写代码的时候想要接收post参数大家一般都会只用npm插件:body-parser。但是:</p><p><img src=\"1630122432129.jpg\"></p><p>虽然感觉奇怪，但是并不影响使用，也就不去管他了，有一次我好奇查了一下，发现在Express 4.x官方将这个插件整合到官方包里面了</p><pre><code class=\"NodeJS\"><span class=\"hljs-keyword\">app</span>.<span class=\"hljs-keyword\">use</span>(express.urlencoded({extended: false})); <span class=\"hljs-comment\">// 现在就方便多了，不需要在安装第三方</span>\n<span class=\"hljs-keyword\">app</span>.<span class=\"hljs-keyword\">use</span>(express.json());\n</code></pre><p>这样的话就可以正常使用啦，在Express中接收POST请求的参数<br></p></div></body></html>', '2021-08-28 00:00:00', 'Express4中解决bodyParser已被弃用报错', 11),
(8, 'leetcode4', 'admin', 'JavaScript,leetcode', '<html><head></head><body><div><p><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\">原题地址</a><br></p><p><img src=\"1f2rd85v0.png\"><br></p><p><img src=\"1f2rd8vtq.png\"><br></p><p>解：</p><ol><li>一共有两个数组，需要进行数组合并</li><li>数组需要排序，而且需要判断数组长度的奇数偶数</li><li>如果是奇数就去数组长度除二减0.5如果是偶数就取两个数一个是数组长度除二减一，一个是数组长度除二</li><li>例如：[1,2,3,4,5]取数组长度的一半减0.5就是索引值2也就是数组3</li><li>[1,2,3,4]取数组长度除二减一，一个是数组长度除二，也就是2，和4</li></ol><pre type=\"JavaScript\"><code><span class=\"hljs-keyword\">var</span> findMedianSortedArrays = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums1, nums2</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> arr = nums1.concat(nums2); <span class=\"hljs-comment\">//合并数组</span>\n    arr = arr.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">n1, n2</span>) =&gt;</span> n1 - n2); <span class=\"hljs-comment\">//排序</span>\n    <span class=\"hljs-keyword\">let</span> isOdd = arr.length % <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">//检测数组是不是奇数</span>\n    <span class=\"hljs-keyword\">let</span> index = isOdd ? arr.length / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">0.5</span> : [arr.length / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>, arr.length / <span class=\"hljs-number\">2</span>]; <span class=\"hljs-comment\">//算出奇数偶数，算出要取的索引值</span>\n    <span class=\"hljs-keyword\">let</span> value = isOdd ? arr[index] : (arr[index[<span class=\"hljs-number\">0</span>]] + arr[index[<span class=\"hljs-number\">1</span>]]) / <span class=\"hljs-number\">2</span>\n    <span class=\"hljs-keyword\">return</span> value;\n};\n<span class=\"hljs-built_in\">console</span>.log(findMedianSortedArrays([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]));</code></pre></div></body></html>', '2021-04-09 00:00:00', 'leetcode第四题寻找两个正序数组的中位数', 15),
(9, 'leetcode14', 'admin', 'JavaScript,leetcode', '<html><head></head><body><div><p><img src=\"1630120983915.jpg\"></p><p><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/submissions/\" target=\"_blank\">原题地址</a><br></p><p><br><img src=\"1630120506400.jpg\"><br><br></p><pre><code class=\"JavaScript\"><span class=\"hljs-comment\">/**\n * @param {string[]} strs\n * @return {string}\n */</span>\n<span class=\"hljs-built_in\">var</span> longestCommonPrefix = function (strs) {\n    <span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"\"</span>;\n\n    <span class=\"hljs-keyword\">for</span> (let <span class=\"hljs-keyword\">index</span> = <span class=\"hljs-number\">0</span>; <span class=\"hljs-keyword\">index</span> &lt; strs[<span class=\"hljs-number\">0</span>].split(<span class=\"hljs-string\">\'\'</span>).length; <span class=\"hljs-keyword\">index</span>++) {\n        let item = strs[<span class=\"hljs-number\">0</span>].split(<span class=\"hljs-string\">\'\'</span>)[<span class=\"hljs-keyword\">index</span>];\n        let result = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-keyword\">for</span> (let i = <span class=\"hljs-number\">0</span>; i &lt; strs.length; i++) {\n            <span class=\"hljs-keyword\">if</span> (item != strs[i][<span class=\"hljs-keyword\">index</span>]) {\n                result = <span class=\"hljs-literal\">false</span>;\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (result) {\n            <span class=\"hljs-built_in\">str</span> += item;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">str</span>;\n};</code></pre><p><br></p><p><br>虽然我的解法比较烂，但是我还是决定要分享一下：</p><ol><li>题目表达非常清楚，寻找公共前缀</li><li>我们将数组中的第一个字符串元素转为数组进行forEach（不转也行，使用for）</li><li>遍历剩余字符串，根据遍历第一个字符串的循环的索引值进行对比，一旦有不相同的就跳出循环，返回最终结果</li></ol><p><br></p></div></body></html>', '2021-08-28 00:00:00', 'LeetCode14 最长公共前缀', 12),
(10, 'leetcode1', 'admin', 'leetcode,JavaScript', '<html><head></head><body><div><h2 id=\"f68ko\"><p><a href=\"https://leetcode-cn.com/problems/two-sum/\" target=\"_blank\">原题地址</a><br></p><p>要求：</p><img src=\"1f1u3vj5k.png\"></h2><h2 id=\"f68ko\"></h2><h3><span style=\"font-weight: normal;\" id=\"uiik9\">解：</span></h3><pre type=\"JavaScript\"><code><span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">{number[]}</span> <span class=\"hljs-variable\">nums</span></span>\n * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">{number}</span> <span class=\"hljs-variable\">target</span></span>\n * <span class=\"hljs-doctag\">@return <span class=\"hljs-type\">{number[]}</span></span>\n */</span>\n<span class=\"hljs-comment\">// var twoSum = function (nums, target) {</span>\n<span class=\"hljs-comment\">//     for (let i = 0, j = nums.length - 1; i &lt; j; i++) {</span>\n<span class=\"hljs-comment\">//         for (let x = i + 1, z = nums.length; x &lt; z; x++) {</span>\n<span class=\"hljs-comment\">//             if (nums[i] + nums[x] === target) {</span>\n<span class=\"hljs-comment\">//                 return [i, x];</span>\n<span class=\"hljs-comment\">//             }</span>\n<span class=\"hljs-comment\">//         }</span>\n<span class=\"hljs-comment\">//     }</span>\n<span class=\"hljs-comment\">// };</span>\n<span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums, target</span>) </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = i+<span class=\"hljs-number\">1</span>; j &lt; nums.length; j++) {\n            <span class=\"hljs-keyword\">if</span> (nums[i] + nums[j] == target ) {\n                <span class=\"hljs-keyword\">return</span> [i, j]\n            }\n        }\n    }\n};\n<span class=\"hljs-built_in\">console</span>.log(twoSum([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>], <span class=\"hljs-number\">4</span>));</code></pre><p><span style=\"font-weight: normal;\"><i><font size=\"3\">//上面被注释的代码是身边别人写的</font></i></span></p><p>！！：</p><p>主要意思就是一个函数有两个参数一个参数是数组，另一个参数是数字，数组内有几个值也都是数字，他们当中有两个数字加起来的和为函数的第二个参数也就是图片中的target</p><p>注解：</p><pre type=\"JavaScript\"><code><span class=\"hljs-keyword\">//既然是在数组中寻找两个数字的和那么大家第一反应应该都是两个循环</span></code><code><span class=\"hljs-keyword\"><br></span></code><code><span class=\"hljs-keyword\">var</span> twoSum = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nums, target</span>) </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = i+<span class=\"hljs-number\">1</span>; j &lt; nums.length; j++) {</code><code><br></code><code>//简单的来说就是一直循环数组来判断两数之和，在两数之和为target时返回函数\n            <span class=\"hljs-keyword\">if</span> (nums[i] + nums[j] == target ) {\n                <span class=\"hljs-keyword\">return</span> [i, j]\n            }\n        }\n    }\n};\n<span class=\"hljs-built_in\">console</span>.log(twoSum([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>], <span class=\"hljs-number\">4</span>));</code></pre></div></body></html>', '2021-03-29 00:00:00', 'leetcode第一题两数之和', 23),
(11, 'leetcode3', 'admin', 'JavaScript,leetcode', '<html><head></head><body><div><p>其实这篇我是有点不好意思发出来的</p><p><b id=\"eewjk\"><font size=\"5\">原因：</font></b></p><p><img src=\"1f26rkn1i.png\"></p><p>后来想了想毕竟做出来了，也是分享一下以后有什么新方法可以在下面接着写。</p><p>原题：<a href=\"https://leetcode-cn.com/problemset/all/\" target=\"_blank\">https://leetcode-cn.com/problemset/all/</a></p><p><img src=\"1f26rnhp9.png\"></p><p>主要就是在一串长字符串里面找最长的子串，</p><pre type=\"JavaScript\"><code><span class=\"hljs-built_in\">var</span> lengthOfLongestSubstring = function (s) {\n    <span class=\"hljs-built_in\">let</span> arr = [];\n    <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">max</span> = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; s.<span class=\"hljs-built_in\">length</span>; i++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> j = i; j &lt; s.<span class=\"hljs-built_in\">length</span>; j++) {\n            <span class=\"hljs-keyword\">if</span> (!arr.includes(s[j])) {\n                arr.<span class=\"hljs-built_in\">push</span>(s[j])\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-built_in\">max</span> = arr.<span class=\"hljs-built_in\">length</span> &gt; <span class=\"hljs-built_in\">max</span> ? arr.<span class=\"hljs-built_in\">length</span> : <span class=\"hljs-built_in\">max</span>;\n                arr = [];\n                <span class=\"hljs-built_in\">break</span>;\n            }\n        }\n    }\n    <span class=\"hljs-built_in\">return</span> s.<span class=\"hljs-built_in\">length</span> == <span class=\"hljs-number\">1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-built_in\">max</span>;\n};</code></pre><p>多次遍历，并且创造一个空数组来暂存数据，每次存入数组是判断数组是否有相同的值，如果有就清空数组，并且判断本次的长度是否长于上次，如果长于上次就更新，之后终止循环，在循环结束后判断，因为题目特意说明\" \"空格也算长度，但是本程序没没有针对单个空格的判断，就只能在return的时候判断长度是否为1了<span style=\"font-size: 1em;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p></div></body></html>', '2021-04-01 00:00:00', 'leetcode第三题无重复字符的最长子串', 22),
(12, 'nodeexpress', 'admin', 'nodeJs', '<html><head></head><body><div><p>作为前端程序员在平时也难免会编写一点后台Demo级别的代码，在语言选择上通常会选择Node.js作为主力工具，框架通常会选择老牌框架Express，在本文会讲解一个使用Express创建接口和搭建基本的Express</p><h2 id=\"5bmeq\">创建项目</h2><ol><li>创建一个文件夹后使用cd projectname 进入文件夹<br></li><li>使用npm init创建项目 输入命令行之后一路回车就行</li><li>安装常用的依赖 yarn add express cors nodemon</li><li>创建基本的文件夹结构<br><img src=\"1630914822114.jpg\"><br></li><li>创建一个src文件夹用来存放主要代码，创建一个route来存放接口文件</li><li>将package.json中的script中创建一个start命令：<i>\"start\":&nbsp;\"nodemon&nbsp;--watch&nbsp;./src&nbsp;./src/index.js\"</i>&nbsp; 这样使用yarn start就可以启动项目</li></ol><h2 id=\"kztuz\">配置入口</h2><h3 id=\"hrk5w\">&nbsp;index.js</h3><pre><code class=\"NodeJS\">const express = require(<span class=\"hljs-string\">\"express\"</span>);\nconst app = express();//使用Express</code><code class=\"NodeJS\">//接收POST请求的参数\napp.use(\n  express.urlencoded({\n    extended: false,\n  })\n);\napp.use(express.json());\n//通常设置robots.txt禁止搜索引擎扫描</code><code class=\"NodeJS\">app.use(<span class=\"hljs-string\">\'/robots.txt\'</span>, express.static(<span class=\"hljs-string\">\'./file/robots.txt\'</span>));\n//设置跨域\nconst cors = require(<span class=\"hljs-string\">\"cors\"</span>);\napp.use(cors());\n\n//监听端口\napp.listen(<span class=\"hljs-number\">3000</span>, () =&gt; console.log(`run`));\n</code></pre><p>这样是配置基本的入口文件<br></p><ol><li>配置接口</li></ol><p>创建一个.js的文件</p><pre><code class=\"NodeJS\"><span class=\"hljs-keyword\">const</span> express = require(<span class=\"hljs-string\">\'express\'</span>);\n<span class=\"hljs-keyword\">const</span> app = express();\n<span class=\"hljs-keyword\">const</span> router = express.Router();\n\nrouter.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">\'/\'</span>, <span class=\"hljs-keyword\">async</span> (req, res) =&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">get</span> = req.query; <span class=\"hljs-comment\">//接收get请求参数</span>\n    <span class=\"hljs-keyword\">let</span> post = req.body; <span class=\"hljs-comment\">//接收post请求参数</span>\n    res.json({\n        key: <span class=\"hljs-string\">\'value\'</span>\n    })\n})\nmodule.exports = router;</code></pre><ol><li>引入express和express.router</li><li>设置路由的请求方式（常用:get,post,put,delete），设置路由请求路径</li><li>req是请求相关信息，我们可以使用req.query和req.body来接收请求参数</li><li>对数据库或相关业务逻辑进行处理之后我们使用res进行返回res常用的返回方式就是json，返回对象前端接收进行服务器渲染，方便前后端分离</li></ol><h4 id=\"r7rkz\">路由引用</h4><p>在index.js中将编写好的接口挂载到入口文件中</p><pre><code class=\"NodeJS\" id=\"vb4de\">app.<span class=\"hljs-keyword\">use</span>(<span class=\"hljs-string\">\'/\'</span>, <span class=\"hljs-keyword\">require</span>(<span class=\"hljs-string\">\'./route/express\'</span>));</code></pre><h4 id=\"jtuzl\">运行 yarn start 运行项目</h4><p>我们使用postman请求一下</p><p><img src=\"1630920797664.jpg\"><br><img src=\"1630920908483.jpg\"><br>成功接收到服务器返回的数据</p><h4 id=\"bp0u8\">批量引用</h4><p>如果有很多接口我们需要一个一个引用是一件很麻烦的事情，我们可以使用循环将route中的文件都视为路由文件统一引用</p><pre><code class=\"NodeJS\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fileDisplay</span>(<span class=\"hljs-params\">filePath</span>) </span>{\n  fs.readdir(filePath, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, files</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (err) {\n      <span class=\"hljs-built_in\">console</span>.warn(err);\n    } <span class=\"hljs-keyword\">else</span> {\n      files.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">filename</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> filedir = path.join(filePath, filename);\n        fs.stat(filedir, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">eror, stats</span>) </span>{\n          <span class=\"hljs-keyword\">if</span> (eror) {\n            <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">\'获取文件stats失败\'</span>);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">var</span> isFile= stats.isFile();\n            <span class=\"hljs-keyword\">var</span> isDir = stats.isDirectory();\n            <span class=\"hljs-keyword\">if</span> (isFile) {\n              app.use(<span class=\"hljs-string\">\'/\'</span>, <span class=\"hljs-built_in\">require</span>(filedir));\n            }\n            <span class=\"hljs-keyword\">if</span> (isDir) {\n              fileDisplay(filedir);\n            }\n          }\n        });\n      });\n    }\n  });\n}\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'fs\'</span>);\n<span class=\"hljs-keyword\">var</span> path= <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'path\'</span>);\n<span class=\"hljs-keyword\">var</span> filePath = path.resolve(<span class=\"hljs-string\">\'./src/route\'</span>);//填写存放路由的文件夹\nfileDisplay(filePath);</code></pre><p><br></p><div><br></div></div></body></html>', '2021-09-06 00:00:00', 'Express的使用', 22),
(13, 'leetcode7', 'admin', 'leetcode,JavaScript', '<html><head></head><body><div><p><a href=\"https://leetcode-cn.com/problems/reverse-integer/\" target=\"_blank\">原题地址</a><br></p><p><img src=\"1626749852253.jpg\"></p><p><img src=\"1626749882776.jpg\"></p><h2><b id=\"rn9j9\">题解：</b></h2><p><img src=\"1626749926024.jpg\"></p><ol><li>不清楚参数是整数还是负数，我们先用变量保存</li><li>获取参数是绝对值</li><li>因为js中数组有内置的反转函数（reverse），我们将数字转为字符串在转为数组后进行反转，在转为字符串<br></li><li>转为字符串后我们将它与model变量相乘，如果原本的参数大于1就*1，如果原本参数就是小于1的负数就*-1</li><li>因为题目规定了反转好的数字有范围限制，我们来进行范围对比</li><li>**计算符号为求次幂，例如：2**31就是求2的31次幂</li><li>对比后返回计算结果</li></ol><p><br></p></div></body></html>', '2021-07-20 00:00:00', 'LeetCode7 整数反转', 14),
(14, 'leetcode8', 'admin', 'JavaScript,leetcode', '<html><head></head><body><div> <p><a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi/submissions/\" target=\"_blank\">原题地址</a></p><p><img src=\"1627192598614.jpg\"></p><p>看题可得;</p><ol><li>传进来的参数是字符串，需要返回数字</li><li>我们返回的数字要在范围之内，并且要注意正负</li><li>如果第一个除符号之外的字符，无法转换为数字，直接返回0</li></ol><p><b><font size=\"5\">解：</font></b></p><p><img src=\"1627192542158.jpg\"><br><br></p><p><img src=\"1627192809814.jpg\"></p><p><br></p><ol><li>在JS中有一个投机取巧的小方法:parseInt()</li><li>这个函数能直接解决本题大部分需求<a href=\"https://www.w3school.com.cn/js/jsref_parseInt.asp\" target=\"_blank\">参考</a></li><li>如果无法解析出数字会返回NaN，如果可以解析出数字会直接返回数字我们只需要判断范围就好</li><li>我们定义变量number后直接判断，如果isNaN成立说明没有解析出数字，直接返回0</li><li>如果没返回0，开始判断范围，题目中要求如果超出范围直接返回范围的值就可以，我们使用**符号来求次幂（Math.pow函数也可以达到同样的效果）</li><li>如果不在指定范围内我们返回范围，如果在指定范围内我们只需要返回number本身就可以</li></ol><p>!!:也可以用s.split(\'\')将字符串转为数组后遍历使用变量叠加的方法，需要正则表达式来逐个校验，有兴趣想小伙伴可以试一下</p><p><br></p></div></body></html>', '2021-07-25 00:00:00', 'Leetcode8字符串转换整数 (atoi)', 20),
(15, 'react', 'admin', 'React', '<html><head></head><body><div><p><b>什么是React？</b><br></p><p>React是Facebook开源的用于构建用户界面的 JavaScript 库，通过js开控制页面dom，整个网站只有一个HTML文件，通过js来控制页面原素的增删改查</p><p><b>为什么使用React？</b></p><ol><li>组件化开发，方便复用，也是当前WEB开发趋势</li><li>技术成熟，社区活跃，解决方案众多，配件更加齐全</li><li>Facebook大厂维护可靠</li><li>核心库使用简单，支持服务器渲染适合大部分B、C端产品</li></ol><h2 id=\"2vh84\">JSX/TSX</h2><p>jsx是编写React组件的一种方式（tsx是在jsx中使用typescript），可以让我们在js中编写HTML，</p><p>jsx组件为函数组件和类组件，本文主讲解函数组件，在react v16.8之前函数组件是只能写静态UI的不能动态控制DOM，后来React发布了React Hooks</p><pre><code class=\"React\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">componentsname</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我是一个组件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> componentsname;\n</code></pre><p><br></p><p>我们定义一个函数并且导出，这就是一个简单的函数组件，此时页面显示的是一个<i style=\"background-color: rgb(238, 236, 224);\">&lt;div&gt;我是一个组件&lt;/div&gt;</i>，在jsx中所有展示的UI都需要由函数return出去，为了方便换行return一般都是添加括号，不同于Vue3，React必须有一个根组件，我们在这里可以选择用空标签代替<i style=\"background-color: rgb(238, 236, 224);\">&lt;&gt;&lt;/&gt;</i>（这在React中是被允许的），很多小伙伴都要学过Vue，知道Vue有个很好用的东西叫双向绑定，在React中也为我们提供了对应的方法</p><pre><code class=\"React\"><span class=\"hljs-keyword\">import</span> { useState, Fragment } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">componentsname</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [num, setNum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我现在显示的数字是:{num}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> componentsname;\n</code></pre><p><br></p><p>打出这段代码后页面显示的应该是:我现在显示的数字是0，对于这段代码<i style=\"background-color: rgb(238, 236, 224);\">const [num, setNum] = useState(0);</i><span style=\"background-color: rgb(255, 255, 255);\">&nbsp;很多小伙伴不是很理解</span></p><p>这个相当于定义了一个变量，第一个参数为变量，第二个参数为触发双向绑定的函数，useState中的参数是初始值，在jsx中也有类似Vue v-on指令的事件绑定</p><h2 id=\"duke9\">JSX中事件绑定</h2><pre><code class=\"React\"><span class=\"hljs-keyword\">import</span> { useState, Fragment } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">componentsname</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [num, setNum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我现在显示的数字是:{num}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setNum(num+1)}&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> componentsname;\n</code></pre><p><br></p><p>不同的是区别于Vue和原生js，jsx中事件时onEvent，小驼峰命名法，on小写事件名字首字母大写，这样每当我们点击一次按钮数字就会加1</p><p>当然只有在传递参数的时候<i style=\"background-color: rgb(238, 236, 224);\">&lt;button&nbsp;onClick={()&nbsp;=&gt;&nbsp;setNum(num&nbsp;+&nbsp;1)}&gt;&lt;/button&gt;</i>才会写为返回一个函数</p><p>如果触发事件不需要参数：</p><pre><code class=\"React\"><span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">componentsname</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [num, setNum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">show</span>(<span class=\"hljs-params\"></span>) </span>{\n      alert(<span class=\"hljs-string\">`现在的数字是：<span class=\"hljs-subst\">${num}</span>`</span>)\n  }\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我现在显示的数字是:{num}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{show}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> componentsname;\n</code></pre><p><br></p><p>这样编写也可以绑定事件，前提是函数不需要传递参数</p><h2 id=\"8uvyd\">JSX中条件渲染</h2><p>如果想想v-if一样执行条件渲染该怎么办呢？</p><pre><code class=\"React\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我现在显示的数字是:{num}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      {num&gt;4&amp;&amp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>num大于4了<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>}\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setNum(num+1)}&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre><p><br></p><p>使用js中的判断方法&amp;&amp;前面是判断条件后面是DOM节点，节点是肯定被转化为true的，只要前面的条件满足节点就会被显示出来，如果想要实现if...else...，可以在函数变量中使用，如果实在return的UI层使用就只能使用三元表达式，因为jsxUI层只支持表达式</p><pre><code class=\"React\"><span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">componentsname</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [num, setNum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> UI = <span class=\"hljs-function\">() =&gt;</span> num &gt; <span class=\"hljs-number\">4</span> &amp;&amp; <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>num大于4了<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我现在显示的数字是:{num}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      {UI}\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setNum(num + 1)}&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> componentsname;\n</code></pre><p><br></p><p>或者在UI中使用三元表达式</p><pre><code class=\"React\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我现在显示的数字是:{num}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      {num&gt;4?<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>num大于4了<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>:null}\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setNum(num + 1)}&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/&gt;</span></code></pre><p><br></p><p>相同的需求React中有非常多的实现方法，视开发者或者开发团队的习惯而定</p><h2 id=\"kpdfl\">JSX中循环渲染</h2><p>在循环渲染中我们可以使用js自带的数组函数map</p><pre><code class=\"React\"><span class=\"hljs-keyword\">import</span> { useState, Fragment } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">componentsname</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> data = [\n    {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"小刘\"</span>,\n      <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span>,\n    },\n    {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"小王\"</span>,\n      <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">17</span>,\n    },\n    {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"小红\"</span>,\n      <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">11</span>,\n    },\n  ];\n  <span class=\"hljs-keyword\">const</span> UI = data.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Fragment</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n          我是第{index + 1}位同学{item.name}\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>我今年{item.age}岁了<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Fragment</span>&gt;</span></span>\n    );\n  });\n return &lt;&gt;{UI}&lt;/&gt;;//将循环渲染的DOM返回\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> componentsname;\n</code></pre><p><br></p><p>这样的话就会出现3个div标签，每个div标签中有两个p标签，分别介绍自己的名字和年龄，但是在控制台式会报出错误的，和Vue一样，在虚拟DOM中节点都会有唯一一个key作为id，一遍更加方便的被React内部操作，这个<b>Fragment</b>也相当于&lt;&gt;&lt;/&gt;只不过这个标签可以绑定key直接中空标签React是不允许绑定key的。</p><pre><code class=\"React\"><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Fragment</span> <span class=\"hljs-attr\">key</span>=</span></span><span class=\"hljs-template-variable\">{item.name}</span><span class=\"xml\"><span class=\"hljs-tag\">&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n          我是第</span><span class=\"hljs-template-variable\">{index + 1}</span><span class=\"xml\">位同学</span><span class=\"hljs-template-variable\">{item.name}</span><span class=\"xml\">\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>我今年</span><span class=\"hljs-template-variable\">{item.age}</span><span class=\"xml\">岁了<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Fragment</span>&gt;</span></span></code></pre><p>这下我们将key绑定到Fragment标签上，报错就会显示，页面会展示同学们的年龄和名字，在map中所有需要展示在UI层的DOM都是要return的和原生JS相同</p><p>关于<a href=\"https://blogweb.cn/article/reacthooks\" target=\"_blank\">React函数组件生命周期</a>可以在这篇文章学习</p><h2 id=\"ck1a9\"><b></b>编写CSS样式</h2><p>因为React是一个js库，DOM是由js生成的所以在绑定class的时候我们使用的className：</p><pre><code class=\"React\">&lt;<span class=\"hljs-keyword\">div</span> className=<span class=\"hljs-string\">\"style\"</span>&gt;我是一个红色的<span class=\"hljs-keyword\">div</span>&lt;/<span class=\"hljs-keyword\">div</span>&gt;</code></pre><p>css方案推荐使用sass，可以去我的页面搜索sass相关教程</p><p>有的时候我们也会编写行内css</p><pre><code class=\"JavaScript\"><span class=\"xml\"> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=</span></span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">backgroundColor:</span><span class=\"hljs-string\">\'red\'</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\">&gt;</span>我是一个红色的div<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></code></pre><p>如果你的属性key不是一个单词（如：background-color），请将他们转为小驼峰backgroundColor，属性的value类型为字符串可以使用字符串拼接，有的小伙伴会有疑问，为什么style绑定的是两个大括号？其实问题很简单，jsx中与变量绑定的属性都是使用大括号，因为绑定的行内样式本省也是一个对象，所以外面的大括号提示这是一个jsx的绑定，里面的大括号是一个对象，记录了需要绑定的样式</p><pre><code class=\"React\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">componentsname</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> style = {\n    <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">\"red\"</span>,\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">\"black\"</span>,\n  };\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{style}</span>&gt;</span>我是一个红色的div<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> componentsname;</code></pre><p>当然我们也可以使用上面的这种方式来绑定，这种方式更直观的显示出style属性其实绑定的是一个js对象</p><h2 id=\"3rua6\">总结：</h2><ol><li>React与Vue基本相同也是单页面应用</li><li>循环渲染使用js的map，将需要使用的DOM节点return出去</li><li>条件渲染可以使用&amp;&amp;判断，或者使用三元表达式执行更复杂的判断</li><li>事件绑定采用onEvent小驼峰命名，on小写事件名字首字母大写，如果需要传递参数使用()=&gt;function(param)</li><li>绑定class请使用className，绑定行内样式使用style={样式对象}</li></ol></div></body></html>', '2021-07-02 00:00:00', 'React入门', 11),
(16, 'nodeffmpeg', 'admin', 'nodeJs', '<html><head></head><body><div><p>最近接了一个公司的小项目，上一位程序要留下的最大的问题就是：使用node对音频和视频进行处理？</p><p>他们决定找我丢下之前的包袱重新进行开发，为了这个问题当时研究了大半天，决定分享出来</p><p>主要使用的就是一个叫<a href=\"https://www.ffmpeg.org/\" target=\"_blank\">ffmpeg</a>的工具，而且使用有两种使用方法：</p><p>一种是内置的工具需要下载并且配置环境变量、<span style=\"font-size: 1em;\">另一种是使用</span><a href=\"https://www.npmjs.com/package/ffmpeg\" target=\"_blank\" style=\"font-size: 1em;\">npm内置的包</a></p><p>我当时是没有发现npm包的办法所以使用了cmd命令的方法：</p><p>首先在我们的电脑中安装ffmpag工具（<a href=\"https://zhuanlan.zhihu.com/p/118362010\" target=\"_blank\">方法传送门</a><span style=\"font-size: 1em;\">），安装后使用</span>npm install node-cmd –save安装运行命令的工具</p><pre type=\"JavaScript\"><code>  let <span class=\"hljs-keyword\">cmd</span><span class=\"bash\"> = `ffmpeg -i <span class=\"hljs-string\">\"./audio/<span class=\"hljs-variable\">${name}</span>\"</span> -ab 128 <span class=\"hljs-string\">\"./audio/min-<span class=\"hljs-variable\">${name}</span>\"</span>`</span></code></pre><p>这是我当时的使用方法 第一个地址是输入地址，第二个地址是输出地址，128是采样率。</p><p>当时我还加入了&nbsp;<i></i><span style=\"background-color: rgb(241, 241, 241);\"><i>-f fmt 强迫采用格式fmt&nbsp;&nbsp;</i>将输出格式转为了mp3音频也是同样的处理方法</span></p><p><span style=\"background-color: rgb(241, 241, 241);\">参数参考：</span><span style=\"background-color: rgb(241, 241, 241);\">-r fps 设置帧频&nbsp;&nbsp;</span></p><p><span style=\"background-color: rgb(241, 241, 241);\"><br></span></p><p><span style=\"background-color: rgb(241, 241, 241);\">参数查询：</span><a href=\"https://www.jianshu.com/p/049d03705a81\" target=\"_blank\">参数参考</a></p><p><br></p><p>设置好cmd命令行后：</p><pre type=\"nodeJS\"><code>\n<span class=\"hljs-keyword\">var</span> nodeCmd = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'node-cmd\'</span>);\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">runCmdTest</span>(<span class=\"hljs-params\"></span>) </span>{\n    nodeCmd.get(\n        <font color=\"#98c379\">cmd</font>,\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, data, stderr</span>)</span>{\n            <span class=\"hljs-built_in\">console</span>.log(data);</code><code>//运行后的回调函数\n        }\n    );\n\n}</code></pre><p><br></p><p><span style=\"background-color: rgb(241, 241, 241);\"><br></span></p></div></body></html>', '2021-04-18 00:00:00', 'node压缩处理音频和视频', 13),
(17, 'reacthooks', 'admin', 'React,JavaScript', '<html><head></head><body><div><p>在<b>React v16.8</b>中官方推出了<b>Hooks</b>，该方案会取代大部分的类组件主要解决了函数组件无法使用状态的问题</p><h1 id=\"5qb0u\">React Hooks</h1><p>在官方为我们提供的Hook中，主要解决的就是使用状态和生命周期的问题</p><h2 id=\"inlib\">useState</h2><p>在原来的函数组件中我们只可以做静态展示内容无法实现双向绑定的交互：</p><pre type=\"React\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Component</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我是一个函数组件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n</code></pre><p>因此官方提供了<span style=\"font-size: 1em;\"><b>useState</b>钩子</span><br></p><pre type=\"React\"><code><span class=\"hljs-keyword\">import</span> React, { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Component</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [state, setstate] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">let</span> num = state + <span class=\"hljs-number\">1</span>;\n    setstate(num);\n  }\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我是一个函数组件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>现在的数字是：{state}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{add}</span>&gt;</span>点我加一<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n</code></pre><p>对于const定义的数组大多是人还是比较陌生的，这就是官方所给的hooks，数组中第一个参数为设置的值，第二个参数是修改这个值的函数，正向add函数中的那样setState中的参数就是要修改后的值useState函数中的0就是默认的值，当然也相当于类组件中的<span style=\"font-size: 1em;\">getDerivedStateFromProps生命周期可以在useState函数中直接使用props传来的值</span><br></p><h2><span style=\"font-size: 1em;\" id=\"vl34k\">useEffect</span></h2><p><span style=\"font-size: 1em;\" id=\"f91fv\">接下来还是生命周期问题</span>官方提供<span style=\"font-size: 1em;\"><b>useEffect</b>函数来解决</span></p><pre type=\"React\"><code>  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n\n    \n  })</code></pre><p>这个函数相当于每次更新都是使用</p><pre type=\"React\"><code>  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n\n    \n  },[])</code></pre><p>如果加了这个就只在组件挂载后使用了，可能有人会疑惑第二个参数为啥是一个空数组呢？<br></p><p>这个就行相当于vue中的watch函数</p><pre type=\"React\"><code>  useEffect(() =&gt; {\n\n    \n  },[<span class=\"hljs-keyword\">state</span>])</code></pre><p>这样的话就相当于监听state，每次state变化了就会执行函数<br></p><p>除此之外还提供了组件销毁的生命周期</p><pre type=\"React\"><code>  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"组件创建\"</span>);\n    <span class=\"hljs-keyword\">return</span> () =&gt; {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"组件销毁\"</span>);\n    };\n  }, []);</code></pre><p>此方法需要在函数中在返回一个函数可以与组件创建生命周期写在一个函数中<br></p><h2 id=\"4llkr\">useMemo</h2><h2></h2><p>这个Api相当于Vue中的computed，也算是React中的计算属性</p><p>使用方法：</p><pre><p><code>const articleData = useMemo(() =&gt; data, [data]);<br></code></p></pre><p><i>一共有两个参数</i>第一个是函数有一个返回值返回的是最终的计算结果，第二个和useEffect的数组差不多，是一个依赖项，只要数组中的元素有变化就会重新计算参数函数，useMemo的返回值为计算结果</p><h2>useRef</h2><p>在React函数组件中我们可以使用useRef来保存变量和获取DOM（相当于类组件中的createRef）</p><p>和createRef相同在我们我们定义的ref也是一个对象</p><pre><code>let ref=useRef(0)//{current:0}</code></pre><p>这样我们就定义了一个ref来存储变量，修改这个变量也是通过修改current</p><p>例如：ref.current=1</p><pre><code>let dom=ref(null)\nreturn(\n  &lt;div ref={dom}&gt;我是一个被useRef选中的div标签&lt;/div&gt;\n)</code></pre><p>这样的话我们通过获取dom的current属性就可以直接拿到被选中的标签了<br></p><h2>useContext</h2><p>这个Hooks主要用于组件传值不同于props这个Hooks是通过引入使用的所有不会对组件层级有限制</p><p>1.我们需要先定义useContext</p><pre><code>const Count= createContext(0)</code></pre><p>2.使用定义的context包裹需要接收值的组件将要传递的数据通过value传递</p><pre><code>&lt;Count.Provider value={data}&gt;\n&lt;Route/&gt;\n&lt;Route/&gt;\n&lt;/Count.Provider&gt;</code></pre><p>3.使用Context</p><pre><code>function child() {\n  let data = useContext(Count);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n}</code></pre><p>!!:如果是跨JSX文件使用在步骤1 时需要将createContext创建在最外层导出使用时导入</p><h2>useReducer</h2><p>这个Hooks主要是可以配合上文的useContext来实现状态管理类似（redux/vuex）</p><p>useReducer也是有两个参数，第一个参数是进行状态设置，第二个是默认状态，也就是初始值<br></p><p>1.创建useReducer</p><pre><code>const [value, setValue] = useReducer((state, action) =&gt; {\n  value = action;\n}, 0);</code></pre><p>state为被操作值</p><p>action为操作时传来的值</p><p>value是计算后的响应式值<br></p><p>setValue是重新计算：setValue(params) //参数为useReducer中的action</p><p>2.修改结果<br></p><pre><code>setValue(value+1)</code></pre><p>如果我们这样触发那么所有使用到value变量的地方都会加1</p><p>!!:我们可以将这两个Hooks结合到一起实现状态管理，与其他状态管理相同主要操作也是发布/订阅，由useReducer进行数据保存和修改，后由useContext来进行发布<br></p><p><br></p><h2>useCallback</h2><p>这个Hooks相当于一个节流函数</p><pre><code>const memoizedCallback = useCallback(\n  () =&gt; {\n    doSomething(a, b);\n  },\n  [a, b],\n);</code></pre><p>他返回的相当于一个事件,第二个参数也是依赖项，只有某个依赖项有变化函数才可以执行</p><p><br></p><p><b>这些就是基本的React Hooks剩余两个Hooks为useLayoutEffect和useImperativeHandle以及useDebugValue</b><br></p><p><br></p><p>总结:</p><ol><li>Hooks提高了工作效率，并且让组件更加简单</li><li>并且可以自行解决状态管理问题不需要依赖第三方</li><li>部分函数可以集成到一个Hooks中更加方便抽离</li></ol></div></body></html>', '2021-08-25 00:00:00', 'React Hooks', 22);
INSERT INTO `article` (`id`, `router`, `author`, `type`, `article`, `time`, `title`, `view_count`) VALUES
(18, 'reactuseclass', 'admin', 'React,JavaScript', '<html><head></head><body><div><p><b>React</b>中主要分为<b>类组件</b>和函数组件，在本文主要讲解为react中使用类组件：</p><p>我们先定义并导出一个叫Com的类组件</p><pre type=\"React\"><code><span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">React</span>, { <span class=\"hljs-type\">Component</span> } from <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Com</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n    \n}\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">Com</span>;</code></pre><p><span style=\"font-size: 1em;\">接下来我们需要渲染一些Dom，并且定义一些状态数据，在react中响应式数据定义在state变量中</span><br></p><pre type=\"React\"><code><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Com</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> {\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state={\n        <span class=\"hljs-attr\">time</span>:<span class=\"hljs-number\">5</span>\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我是Com组件,现在是{this.state.time}点<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Com;</code></pre><p><span style=\"font-size: 1em;\">现在我们输出了一点div，并报出的现在的时间，每当我们修改state中的time属性是div中输出的时间就会随着改变</span><br></p><pre type=\"React\"><code><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Com</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> {\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = {\n      <span class=\"hljs-attr\">time</span>: <span class=\"hljs-number\">5</span>,\n    };\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">this</span>.setState({\n      <span class=\"hljs-attr\">time</span>: <span class=\"hljs-number\">6</span>,\n    });\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我是Com组件,现在是{this.state.time}点<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Com;</code></pre><p><span style=\"font-size: 1em;\">我在生命周期函数中添加了一段setState来修改属性，现在渲染出的div中的时间也变成了6点</span><br></p><p>现在还有一个需求，就是每次点击渲染的div文字就需要让time加一，这就需要定义点击事件</p><pre type=\"React\"><code><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Com</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> {\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = {\n      <span class=\"hljs-attr\">time</span>: <span class=\"hljs-number\">5</span>,\n    };\n    <span class=\"hljs-built_in\">this</span>.newTime=<span class=\"hljs-built_in\">this</span>.newTime.bind(<span class=\"hljs-built_in\">this</span>);\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">this</span>.setState({\n      <span class=\"hljs-attr\">time</span>: <span class=\"hljs-number\">6</span>,\n    });\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">newTime</span>(<span class=\"hljs-params\"></span>)</span>{\n      <span class=\"hljs-keyword\">let</span> oldTime=<span class=\"hljs-built_in\">this</span>.state.time\n      <span class=\"hljs-built_in\">this</span>.setState({\n          <span class=\"hljs-attr\">time</span>:oldTime+<span class=\"hljs-number\">1</span>\n      })\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.newTime}</span>&gt;</span>我是Com组件,现在是{this.state.time}点<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Com;</code></pre><p><span style=\"font-size: 1em;\">这样的话就可以绑定自定义事件了，</span><span style=\"font-size: 1em;\">在每次点击时获取当前时间后加一</span><br></p><p>!!：每次使用自定义事件时需要在构造器中使用bind函数进行绑定，将函数挂在到class实例上</p><p><b><font size=\"6\">简写方式：</font></b></p><pre type=\"React\"><code><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Com</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n    state = {\n      <span class=\"hljs-attr\">time</span>: <span class=\"hljs-number\">5</span>,\n    };\n  newTime=<span class=\"hljs-function\">()=&gt;</span>{\n      <span class=\"hljs-keyword\">let</span> oldTime=<span class=\"hljs-built_in\">this</span>.state.time\n      <span class=\"hljs-built_in\">this</span>.setState({\n          <span class=\"hljs-attr\">time</span>:oldTime+<span class=\"hljs-number\">1</span>\n      })\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.newTime}</span>&gt;</span>我是Com组件,现在是{this.state.time}点<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Com;</code></pre><p><span style=\"font-size: 1em;\">上面的类组件过于繁琐，增加了很多不必要的麻烦，因此我们可以在今后的开发中使用以上方式来简写</span><br></p><ol><li>state无需在写到构造器当中，直接写成实例属性</li><li>事件函数需要在构造器中使用bind绑定指向，直接使用箭头函数</li><li>state和事件都不在依赖构造器构造器可以不用写</li></ol></div></body></html>', '2021-05-03 00:00:00', 'React中使用类组件', 15),
(19, 'routerandpage', 'admin', 'JavaScript,讲解', '<html><head></head><body><div><h2>前端路由</h2><p>定义：主要用于单页面应用，大部分页面结构不变，只通过JS改变部分内容的使用（例如：react-router,vue-router）<br></p><ul><li>优点：用户体验好，不需要每次都从服务器全部获取，在切换页面时快速展现给用户客户端渲染可以减轻服务器压力<br></li><li>缺点：使用浏览器的前进，后退键的时候会重新发送请求，无法合理地利用缓存刷新无法记住之前滚动的位置（需要配合生命周期手动调整），如果使用客户端渲染不利于SEO，文件大时会出现首页白屏<br></li></ul><p><br></p><h2>后端路由</h2><p>定义:根据window.location.href找到服务端匹配的模板进行渲染，通过服务器渲染和浏览器路径决定内容</p><ul><li>优点:可以方便的使用AJAX或者服务器渲染最新的HTML对SEO友好</li><li>缺点:文件复用不灵活,如果通过后端语言模板实现组件化就要前后端不分离</li></ul><p><br></p><h2>前后端路由对比</h2><p>从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升<br></p><p>但是页面使用浏览器自带的刷新和前进后退前端路由就会重新获取资源，这将造成较大的资源浪费</p><p>在SEO角度讲单页面应用天生对SEO不友好，因为整个页面都是通过JS渲染的，搜索引擎爬虫只能抓取到一个根节点，但是后端路由是经过后端自带的模板框架渲染的（ejs,jsp）已经在服务器拼接好了HTML对搜索引擎蜘蛛会更倾向与后端路由</p><p><br></p><h2>单页面应用</h2><p>优势：</p><ol><li>实际上并不存在页面切换问题，因为整个网站只有一个HTML，通过预先加载好的JS控制页面显示会更流畅，而且可以附加各种动画和过度效果，用户体验更好。<br></li><li>有大量脚手架已经，三大框架的成长使得单页面前后端分离已经成为趋势(--本观点写于2021.08.12)</li></ol><p><br></p><p>劣势:</p><ol><li>还是上面重复的SEO问题只通过JS切换对SEO不友好</li><li>所有页面放到一个HTML中通过JS切换，如果测试有误对漏掉一些BUG很可能影响后续功能</li><li>体积较大，首次加载时间较长，首页白屏问题</li></ol><p><br></p><h2>多页面应用</h2><p>优势:</p><ol><li>逻辑清楚页面直接几乎没有相互影响</li><li>单个页面体积小，加载速度快</li></ol><p><br></p><p>劣势:</p><ol><li>代码冗余</li><li>页面切换体验不好</li></ol><p><br></p><h2>总结</h2><p>1.如果选择前端路由后端路由、单页面与多页面？</p><p>&nbsp; 方案的选择要根据业务而定，如果是面向客户的产品（toC）推荐使用多页面后端路由，如果是面向企业的产品（ToB）推荐使用单页面前端路由</p><p>2.如何解决SEO和首页白屏的问题</p><p>&nbsp; 首先要知道客户端渲染无法解决此问题，我们需要的是保证大部分三大框架优点的同时解决此问题，如果你们网站是纯静态的推荐使用预渲染，如果是根据AJAX动态更新的推荐使用NextJs/NuxtJs等服务器渲染框架</p><p>3.页面中传值问题</p><p>&nbsp; 基本分为通过url传值和加密传值，url传值基本为 window.location.href=href/param方法修改路径或者?a=1&amp;b=2,加密传值类似React的state传值</p><p>4.本站的技术栈选择</p><p>&nbsp; 博客网站是及其注重SEO的因此前台选择了NextJs服务器渲染，前后端分离也更加方便了开发，后台管理采用了Vue3客户端渲染主要节约服务器资源以及更快的切换页面</p></div></body></html>', '2021-08-12 00:00:00', '一文讲解前端路由、后端路由、单页面应用、多页面应用', 25),
(20, 'nextjs', 'admin', 'React', '<html><head></head><body><div><p>NextJs是React的服务器渲染框架，区别于官方SSRNext最大的特点是可以渲染出Ajax异步请求渲染出来的结果，本网站目前使用的前端框架就是NextJs</p><p>本文章默认你已将学会了React，如果你不会React可以去<a href=\"https://blogweb.cn/search\" target=\"_blank\">搜索页面</a>去搜索React相关的文章来学习一下React</p><p>下面我讲一下NextJs和React的区别，Reac他和其他两个框架的主要区别就是官方只会提供核心库剩余的像：路由（react-router），状态管理（redex），或者css（css in js、scss）方案都由社区提供，而Next和React最大的区别就是路由，核心库基本没有区别因为在<a href=\"https://www.nextjs.cn/docs/getting-started\" target=\"_blank\">NextJs官网</a>声明了NextJs是兼容React17的</p><h2 id=\"7jbfq\">创建项目</h2><p>区别于React 这里创建项目是使用<span style=\"background-color: rgb(241, 241, 241);\">yarn create next-app&nbsp; &nbsp;</span>create-next-app name（项目名字）（推荐使用yarn因为npm创建项目会遇到一些网络问题，尤其是安装node-sass的时候）</p><h2 id=\"js6jc\"><b></b>安装插件</h2><p>通常我自己喜欢安装ts和sass，使用命令 yarn add typescript sass</p><p>!!:sass版本一定要与node的版本对应</p><h2 id=\"3cgbd\">启动项目</h2><p>cd name(项目名)</p><p>yarn dev</p><h2 id=\"c4d7q\">使用路由</h2><p><br></p><pre><code class=\"React\"><span class=\"hljs-keyword\">import</span> React, { useState, useEffect, useRef } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> style <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./index.module.scss\"</span>;\n<span class=\"hljs-keyword\">import</span> Link <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/link\"</span>;\n<span class=\"hljs-comment\">// import router from \"next/router\";</span>\n<span class=\"hljs-keyword\">import</span> { Col, Row, BackTop, Button } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"antd\"</span>;\n<span class=\"hljs-keyword\">import</span> {\n  HomeOutlined,\n  SearchOutlined,\n  UserOutlined,\n  DeploymentUnitOutlined,\n  MenuUnfoldOutlined,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@ant-design/icons\"</span>;\n<span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"axios\"</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Header</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> [html, setHtml] = useState&lt;<span class=\"hljs-built_in\">string</span>&gt;(<span class=\"hljs-string\">\"占位的一个注释\"</span>);\n  <span class=\"hljs-keyword\">const</span> header = React.useRef(<span class=\"hljs-literal\">null</span>);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// console.log(header.current);</span>\n\n    axios.get(<span class=\"hljs-string\">\"/message\"</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> index: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * res.data.data.length);\n      setHtml(res.data.data[index].message);\n    });\n  }, []);\n\n  <span class=\"hljs-keyword\">const</span> setAnimation = <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(e);\n  };\n  <span class=\"hljs-keyword\">const</span> [active, setActive] = useState&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>\n      <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{style.header</span> + ` ${<span class=\"hljs-attr\">active</span> &amp;&amp; <span class=\"hljs-attr\">style.header_active</span>}`}\n      <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{header}</span>\n      <span class=\"hljs-attr\">onLoad</span>=<span class=\"hljs-string\">{(e:</span> <span class=\"hljs-attr\">any</span>) =&gt;</span> setAnimation(e)}\n      onClick={(e: any) =&gt; setAnimation(e)}\n    &gt;\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span>\n        <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"primary\"</span>\n        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{</span>`<span class=\"hljs-attr\">phone</span> ${<span class=\"hljs-attr\">style.header_switch_ico</span>}`}\n        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setActive(!active)}\n      &gt;\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MenuUnfoldOutlined</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">dangerouslySetInnerHTML</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">__html:</span> `&lt;!<span class=\"hljs-attr\">--</span>${<span class=\"hljs-attr\">html</span>}<span class=\"hljs-attr\">--</span>&gt;</span>` }}&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Row</span> <span class=\"hljs-attr\">justify</span>=<span class=\"hljs-string\">\"space-between\"</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{style.nav}</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Col</span> <span class=\"hljs-attr\">sm</span>=<span class=\"hljs-string\">{8}</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{style.logo}</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/\"</span>&gt;</span>刘润霖<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>\n            前端<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">textDecoration:</span> \"<span class=\"hljs-attr\">line-through</span>\" }}&gt;</span>大佬<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>小白\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Col</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Col</span> <span class=\"hljs-attr\">sm</span>=<span class=\"hljs-string\">{6}</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/\"</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HomeOutlined</span> /&gt;</span>\n                首页\n              <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/search\"</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">SearchOutlined</span> /&gt;</span> 搜索文章\n              <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/about\"</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">UserOutlined</span> /&gt;</span> 关于作者\n              <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/rss\"</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"phone\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DeploymentUnitOutlined</span> /&gt;</span> 订阅\n              <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Col</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Row</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BackTop</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span></span>\n  );\n}\n</code></pre><p><br></p><p>这是我首页的源码</p><p>大家也注意到了每次我们在路由中导入变量是不在是from react-router-dom,而是变成了next/router,next/link等</p><p>router事件基本也是想react中一样不同的是因为是在服务器渲染的所以在next中新加了一个功能：预加载</p><p><i>router.prefetch(\'/path\')</i><br></p><p>主要适用于js编程式导航， 例如：</p><pre><code class=\"React\">importReactfrom<span class=\"hljs-string\">\'react\'</span>\n<span class=\"hljs-keyword\">import</span>{ withRouter }<span class=\"hljs-keyword\">from</span><span class=\"hljs-string\">\'next/router\'</span>\n \nclassMyLinkextendsReact.Component{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span>{\n<span class=\"hljs-keyword\">const</span>{ router }=<span class=\"hljs-built_in\">this</span>.props\n    router.prefetch(<span class=\"hljs-string\">\'/dynamic\'</span>)\n}\n \n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>{\n<span class=\"hljs-keyword\">const</span>{ router }=<span class=\"hljs-built_in\">this</span>.props\n<span class=\"hljs-keyword\">return</span>(\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span>=&gt;</span>setTimeout(()=&gt; router.push(\'/dynamic\'),100)}&gt;\n          A route transition will happen after 100ms\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n)\n}\n}\n \nexportdefault withRouter(MyLink)</code></pre><p>适用setTimeout进行延迟跳转路由时就是预加载的最佳适用环境。<br></p><p>在Next中没有单独的文件去配置path和components对应</p><p>Next中遵循组件及路由的原则</p><p>在page文件夹中：</p><p><img src=\"1629468639430.jpg\"></p><p>这样的配置就说明我们注册了5个常规路由一个错误时显示的路由</p><p>也可以使用*路由</p><p>在对应的文件夹中使用[...all].tsx</p><p>在本项目我使用了</p><p><img src=\"1629468689332.jpg\"></p><p>这样就相当于注册了article中的所有路由在访问blogweb.cn/article/*</p><p>中凡是article的路由都会进入此文件</p><p><span style=\"font-size: 24px;\">异步请求</span><br></p><p>在Next中最大的特点是会渲染异步请求的结果</p><pre><code class=\"React\"><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"axios\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Home</span>(<span class=\"hljs-params\">{ data }</span>) </span>{\n</code><code class=\"React\">  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n     &lt;div&gt;{data+\'\'}&lt;/div&gt;</span></code><code class=\"React\"><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\nHome.getInitialProps = <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">let</span> data;\n  <span class=\"hljs-keyword\">await</span> axios\n    .get(<span class=\"hljs-string\">\"/article-page/1\"</span>, {\n      <span class=\"hljs-attr\">params</span>: { <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">\"router,title,type,introduce,article,time\"</span> },\n    })\n    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n      data = res.data.data;\n    });\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">data</span>: data,\n  };\n};\n</code></pre><p>例如这个demo，官方提供了getInitialProps生命周期，在这个生命周期中我们可以返回变量作为函数的props，axios注意使用async和await<br></p><p><span style=\"font-size: 24px;\">Link标签跳转</span><br></p><pre><code class=\"React\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HomeOutlined</span> /&gt;</span>\n     首页\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span></code></pre><p>Link必须有子元素包裹，并且有className或者事件绑定只能绑定到子元素上，如果你的子元素不使用a使用其他标签也可以，相当于为你的字元素添加了一个onclick事件，相当于Vue中router-link的tag属性</p><h2 id=\"rto9a\">CSS解决方案</h2><p>想React一样NextJs支持CSS in Js和CSS模块化引入，但是与React不同的是<i>import \'./index.css\'</i>必须在_app.js中引入</p><h2 id=\"50q3m\">使用@代替src文件夹<br><p><span style=\"font-weight: normal;\">原本Next.js创建之后是不会有src文件夹的但是我们可以创一个（</span><a href=\"https://www.nextjs.cn/docs/advanced-features/src-directory\" target=\"_blank\" style=\"font-weight: normal;\">相关文档</a><span style=\"font-weight: normal;\">），然后将样式、模块、组件路由等文件放进去（总之就是关于项目配置的不要放，关于页面的可以）</span></p><p><span style=\"font-weight: normal;\">TS：</span></p><p><img src=\"1629468586940.jpg\"><br><br></p><p><br></p></h2><p>以上基本就是Next不同于React的点，更多知识点还是要参考于<a href=\"https://www.nextjs.cn/\" target=\"_blank\">文档</a></p></div></body></html>', '2021-06-29 00:00:00', 'Next.js的创建与使用', 14),
(21, 'studentachievement1', 'admin', '毕业设计,VUE,nodeJs', '<html><head></head><body><div><h2 id=\"opp3f\">分享毕业设计（学生成绩管理系统）：</h2><p>技术栈：<b>Vue3，Node-Express,MySql,Echarts,Element-Plus组件库</b></p><p>添加权限管理，教师成绩录入之后，需要管理员的权限才能重新修改。还有管理员可以添加删除修改教师、学生。管理员、学生、教师可以修改个人信息，修改登录密码。管理员可以做到按学生班级，按学生学号搜索学生，管理员可以添加课程，删除课程。教师可以录入成绩，修改成绩(在管理员开了权限之后才可以修改)。这是上面没有补充的，你看一下</p><p><span style=\"font-weight: normal;\"></span><span style=\"font-size: 1em;\">学生：</span></p><p>1、验证个人信息，登录系统，<br>2、查询/修改个人基本信息，查看成绩<br>3、查询所有成绩，并得到平均分，总分等指标<br>4、下载成绩<br>5、退出系统<br>&nbsp;<br>教师：<br>1、&nbsp;验证个人信息，登录系统<br>2、&nbsp;查询/修改个人基本信息，能修改登录密码<br>3、&nbsp;查看成绩<br>4、&nbsp;录入成绩<br>5、&nbsp;修改或更新某一个成绩<br>6、&nbsp;查询某一科的平均成绩，以及改科目的最高分最低分。并以echarts对成绩进行统计分析<br>7、&nbsp;打印和下载某一科目的成绩<br>8、&nbsp;退出系统<br>&nbsp;<br>管理员：<br>1、&nbsp;验证信息，登录系统<br>2、&nbsp;添加和修改、删除学生、教师信息<br>3、&nbsp;录入某一个科的成绩<br>4、&nbsp;修改/更新某一科的成绩<br>5、&nbsp;添加通告<br>6、&nbsp;退出系统<br>&nbsp;<br>要做到成绩排序，分类搜索<br></p><p><span style=\"font-size: 1em;\">以上是客户发给我的需求</span><br></p><p><span style=\"font-size: 1em;\"><b>实现效果图：</b></span></p><p><img src=\"1632720835221.jpg\"></p><p><img src=\"1632720862540.jpg\"></p><p><img src=\"1632720890763.jpg\"></p><p><span style=\"font-size: 1em;\">项目分为管理员，学生，和教师，教师可以察看echarts成绩表，和下载excel图表察看成绩</span></p><p><span style=\"font-size: 1em;\">文件压缩包内包含<b>vue项目，node-express项目，sql数据库文件，</b></span></p><p><span style=\"font-size: 1em;\"><b>下载地址：</b></span><a href=\"http://blogweb.cn/files/studentachievement.zip\" target=\"_blank\">点击下载</a></p><p><br></p></div></body></html>', '2021-05-14 00:00:00', '毕业设计学生成绩管理系统分享', 27),
(22, 'nodeexpressmysql', 'admin', 'nodeJs', '<html><head></head><body><div><p>node连接数据库进行增删改查，安装npm包mysql2（<i>npm install mysql2</i>）</p><p>1.创建连接池配置数据库信息</p><pre type=\"JavaScript\"><code> const mysql = require(<span class=\"hljs-string\">\'mysql2/promise\'</span>);\n const pool = mysql.createPool({\n     host: <span class=\"hljs-string\">\'localhost\'</span>,\n     user: <span class=\"hljs-string\">\'root\'</span>,<span class=\"hljs-regexp\">//</span>数据库用户名\n     database: <span class=\"hljs-string\">\'blog\'</span>,<span class=\"hljs-regexp\">//</span>数据库\n     password: <span class=\"hljs-string\">\'\'</span>,<span class=\"hljs-regexp\">//</span>数据库密码\n     waitForConnections: true,<span class=\"hljs-regexp\">//</span>是否允许排队等待\n     connectionLimit: <span class=\"hljs-number\">10</span>,<span class=\"hljs-regexp\">//</span>最大连接数\n     dateStrings: true <span class=\"hljs-regexp\">//</span>时间转字符串（转化格式）\n });\n module.exports = pool;</code></pre><p>2.express创建路由</p><pre type=\"JavaScript\"><code><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'express\'</span>)\n<span class=\"hljs-keyword\">const</span> app = express()\n<span class=\"hljs-keyword\">const</span> router = express.Router()//创建路由\n<span class=\"hljs-keyword\">let</span> pool = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'../../modules/pool\'</span>)//引入配置好的数据库\nrouter.get(<span class=\"hljs-string\">\'/type\'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> {</code><code>//创建路由使用： http://localhost:端口号/type\n    (<span class=\"hljs-keyword\">async</span> () =&gt; {</code><code>//query中使用sql语句，rows是查询\n        <span class=\"hljs-keyword\">const</span> [rows] = <span class=\"hljs-keyword\">await</span> pool.query(<span class=\"hljs-string\">`select * from articletype ORDER BY time DESC;`</span>);\n        res.json({\n//返回出去一段json\n        })\n    })()\n})\n<span class=\"hljs-built_in\">module</span>.exports = router;</code></pre><p><br></p><p>3.挂载到主路由上面</p><pre type=\"JavaScript\"><code>app.use(<span class=\"hljs-string\">\'/\'</span>,<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'./route/type/read-type\'</span>))\napp.listen(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">博客接口运行</span>`))</code></pre><p><br></p></div></body></html>', '2021-05-09 00:00:00', 'NodeExpress连接MySql', 27),
(23, 'vuescriptsetup', 'admin', 'VUE,JavaScript', '<html><head></head><body><div><p>在Vue3组合式api开发中，所有模板中使用的变量都需要return暴露模板，这样会给开发者增加很多心智负担，所以又有了提案script setup</p><p>之前：</p><pre type=\"VUE\"><code><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n</span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">mes</span>}}</span><span class=\"xml\">\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> &gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> {ref} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n<span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n  <span class=\"hljs-keyword\">let</span> mes=ref(<span class=\"hljs-string\">\'我是加载信息\'</span>)\n}\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></code></pre><p>提案：</p><pre type=\"VUE\"><code><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  </span><span class=\"hljs-template-variable\">{{ mes }</span><span class=\"xml\">}\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">setup</span>=<span class=\"hljs-string\">\"prop,</span></span></span><span class=\"hljs-template-variable\">{emit}</span><span class=\"xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">\"</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> </span></span><span class=\"hljs-template-variable\">{ref}</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n  <span class=\"hljs-keyword\">let</span> mes=ref(<span class=\"hljs-string\">\'我是加载信息\'</span>)\n  emit(函数命，参数)<span class=\"hljs-comment\">//子传父</span>\n  <span class=\"hljs-built_in\">console</span>.log(prop.名字);<span class=\"hljs-comment\">//获取父组件的传值</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></code></pre><p>但是在我开发中使用发现变量名字无需return，但是props和ctx参数无法使用，还报出了一些错误</p><p>发现相关报错信息狗，去推特询问作者了<a href=\"https://baike.baidu.com/item/%E5%B0%A4%E9%9B%A8%E6%BA%AA/2281470\" target=\"_blank\">尤雨溪</a>，并且得到了回复：</p><p><img src=\"1f0vk8uh4.jpg\"><br></p><p><span style=\"font-size: 1em;\">简单的看就是我使用的方法过时了，不在使用，在去GitHub察看最新方案后，整理出：</span><br></p><pre type=\"VUE\"><code><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n</span><span class=\"hljs-template-variable\">{{mes}</span><span class=\"xml\">}\n&lt;组件&gt;&lt;/组件&gt;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">setup</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> </span></span><span class=\"hljs-template-variable\">{defineEmit, defineProps, ref}</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-keyword\">import</span> 组件 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/components/组件名字\'</span>\n<span class=\"hljs-keyword\">let</span> mes=ref(<span class=\"hljs-string\">\'我是文字消息\'</span>);\n\n<span class=\"hljs-keyword\">let</span> emit=defineEmit();\nemit(<span class=\"hljs-string\">\'函数名字\'</span>,参数)<span class=\"hljs-comment\">//子&gt;父</span>\n\n<span class=\"hljs-keyword\">let</span> prop=defineProps(</span></span><span class=\"hljs-template-variable\">{\n  name:type\n}</span><span class=\"xml\"><span class=\"javascript\">)\n<span class=\"hljs-built_in\">console</span>.log(prop.name);<span class=\"hljs-comment\">//获取父组件的值</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></code></pre><p>变化：</p><ol><li>prop，emit等参数需要引入（推荐使用vscode函数内使用会直接帮助您引入）</li><li>组件不在components需要定义只需引入</li><li>双向绑定变量不在需要return全部暴露模板</li></ol></div></body></html>', '2021-03-17 00:00:00', 'Vue3组合式apiscript setup提案使用emitprop组件通信', 15),
(25, '7f28142fedb0770e5c1a9ebd02d06680', 'admin', 'React,测试添加类型', '<p>asdasd<br></p><pre><code class=\"language-jsx\"><xmp>language</xmp></code></pre><pre><code class=\"language-jsx\"><xmp>language</xmp></code></pre><pre><code class=\"language-jsx\"><xmp>language</xmp></code></pre><pre><code class=\"language-html\"><xmp>csacsadasd</xmp></code></pre><pre><code class=\"language-css\"><xmp>.w-e-text-container img {\n  width: 60%;\n}\npre {\n  width: 100%;\n  overflow: hidden;\n  white-space: pre-wrap;\n  overflow-wrap: break-word;\n}\n.w-e-text {\n  padding-bottom: 20px !important;\n}</xmp></code></pre>', '2022-01-03 19:23:26', '测试代码块', 65),
(26, 'asdsa', 'admin', 'React', '<p>&nbsp; &nbsp;asdsadasdsaaaaaaaaaaaaaaaaaaaaaaaa阿萨德很快就离合器科教文汇软件课接口获取额客家人环境开启文化人 切我就科融环境科维奇和人均可请问借款人环境开启王鹤润</p>', '2022-01-04 14:47:03', 'asdsad', 0),
(27, '4917a18e479c3221af38ac44057d4908', 'admin', 'React,萨', '<p>import { createRouter, createWebHashHistory, createWebHistory } from \'vue-router\'; const routes = [{ path: \'/\', name: \'Home\', component: () =&gt; import(\'@/Layout/Home.vue\'), children: [{ path: \'/create-music\', component: () =&gt; import(\'@/views/music/create-music.vue\') }, { path: \'/create-singer\', component: () =&gt; import(\'@/views/singer/create-singer.vue\') }] }, ] const router = createRouter({ history: createWebHashHistory(), routes });<br></p><pre><code class=\"language-jsx\"><xmp>import { createRouter, createWebHashHistory, createWebHistory } from \'vue-router\'; const routes = [{ path: \'/\', name: \'Home\', component: () => import(\'@/Layout/Home.vue\'), children: [{ path: \'/create-music\', component: () => import(\'@/views/music/create-music.vue\') }, { path: \'/create-singer\', component: () => import(\'@/views/singer/create-singer.vue\') }] }, ] const router = createRouter({ history: createWebHashHistory(), routes });</xmp></code></pre>', '2022-01-04 16:15:33', 'dsadsa', 50),
(28, 'asd', 'admin', 'Vue', '<p>asd&nbsp;</p>&lt;script&gt;console.log(1)&lt;/script&gt;&lt;script&gt;console.log(1)&lt;/script&gt;&lt;script&gt;console.log(1)&lt;/script&gt;', '2022-01-09 23:12:51', 'asdas', 39),
(35, '82b604f40a1a048b1a0c817fec7220c5', 'admin', 'JavaScript,leetcode', '<div><p><img src=\"http://localhost:3456/image/1630120983915.jpg\"></p><p><a href=\"https://leetcode-cn.com/problems/longest-common-prefix/submissions/\" target=\"_blank\">原题地址</a><br></p><p><br><img src=\"http://localhost:3456/image/1630120506400.jpg\"><br><br></p><pre><code><span>/**\n * @param {string[]} strs\n * @return {string}\n */</span>\n<span>var</span> longestCommonPrefix = function (strs) {\n    <span>var</span> <span>str</span> = <span>\"\"</span>;\n\n    <span>for</span> (let <span>index</span> = <span>0</span>; <span>index</span> &lt; strs[<span>0</span>].split(<span>\'\'</span>).length; <span>index</span>++) {\n        let item = strs[<span>0</span>].split(<span>\'\'</span>)[<span>index</span>];\n        let result = <span>true</span>;\n        <span>for</span> (let i = <span>0</span>; i &lt; strs.length; i++) {\n            <span>if</span> (item != strs[i][<span>index</span>]) {\n                result = <span>false</span>;\n                <span>break</span>;\n            }\n        }\n        <span>if</span> (result) {\n            <span>str</span> += item;\n        } <span>else</span> {\n            <span>break</span>;\n        }\n    }\n    <span>return</span> <span>str</span>;\n};</code></pre><p><br></p><p><br>虽然我的解法比较烂，但是我还是决定要分享一下：</p><ol><li>题目表达非常清楚，寻找公共前缀</li><li>我们将数组中的第一个字符串元素转为数组进行forEach（不转也行，使用for）</li><li>遍历剩余字符串，根据遍历第一个字符串的循环的索引值进行对比，一旦有不相同的就跳出循环，返回最终结果</li></ol><p><br></p></div>', '2022-01-13 15:25:03', 'LeetCode14 最长公共前缀', 47),
(45, '433246456456', 'admin', '测试添加类型', '<p>地方</p>', '2022-02-19 20:15:08', '阿萨德', 1),
(47, 'e189e1ca7de5deb1925c29fb8d81f933', 'admin', '萨,Vue', '<p>拉法基考虑到</p>', '2022-02-19 20:21:04', '卡萨简单看了', 0),
(48, '2101f0bda18b4a9d0f6365b7ca5953d1', 'admin', 'Vue', '<p>sad</p>', '2022-02-19 20:29:01', '阿萨德发多少', 0),
(51, '6cefb82545a7f118052be873a5c37aaa', 'admin', '测试添加类型', '<pre><code class=\"language-css\"><xmp>code[class*=\"language-\"],\npre[class*=\"language-\"] {\n	color: #ccc;\n	background: none;\n	font-family: Consolas, Monaco, \'Andale Mono\', \'Ubuntu Mono\', monospace;\n	font-size: 1em;\n	text-align: left;\n	white-space: pre;\n	word-spacing: normal;\n	word-break: normal;\n	word-wrap: normal;\n	line-height: 1.5;\n\n	-moz-tab-size: 4;\n	-o-tab-size: 4;\n	tab-size: 4;\n\n	-webkit-hyphens: none;\n	-moz-hyphens: none;\n	-ms-hyphens: none;\n	hyphens: none;\n\n}\n\n/* Code blocks */\npre[class*=\"language-\"] {\n	padding: 1em;\n	margin: .5em 0;\n	overflow: auto;\n}\n\n:not(pre) > code[class*=\"language-\"],\npre[class*=\"language-\"] {\n	background: #2d2d2d;\n}\n\n/* Inline code */\n:not(pre) > code[class*=\"language-\"] {\n	padding: .1em;\n	border-radius: .3em;\n	white-space: normal;\n}\n\n.token.comment,\n.token.block-comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n	color: #999;\n}\n\n.token.punctuation {\n	color: #ccc;\n}\n\n.token.tag,\n.token.attr-name,\n.token.namespace,\n.token.deleted {\n	color: #e2777a;\n}\n\n.token.function-name {\n	color: #6196cc;\n}\n\n.token.boolean,\n.token.number,\n.token.function {\n	color: #f08d49;\n}\n\n.token.property,\n.token.class-name,\n.token.constant,\n.token.symbol {\n	color: #f8c555;\n}\n\n.token.selector,\n.token.important,\n.token.atrule,\n.token.keyword,\n.token.builtin {\n	color: #cc99cd;\n}\n\n.token.string,\n.token.char,\n.token.attr-value,\n.token.regex,\n.token.variable {\n	color: #7ec699;\n}\n\n.token.operator,\n.token.entity,\n.token.url {\n	color: #67cdcc;\n}\n\n.token.important,\n.token.bold {\n	font-weight: bold;\n}\n.token.italic {\n	font-style: italic;\n}\n\n.token.entity {\n	cursor: help;\n}\n\n.token.inserted {\n	color: green;\n}\n\n</xmp></code></pre>', '2022-02-19 20:41:49', 'react', 13),
(52, 'a-b', 'admin', 'Vue', '<p><img style=\"max-width:100%;\" contenteditable=\"false\" src=\"a5fe397e5d73549a61b90a24d791f11a.webp\"><img style=\"max-width:100%;\" contenteditable=\"false\" src=\"5c9632b27014c3a44e3aa84facace59c.webp\"><img src=\"941401ec6c8a0466f53f8f41c33c667b.webp\" style=\"max-width:100%;\" contenteditable=\"false\"></p>', '2022-02-20 13:41:51', '的', 3);

-- --------------------------------------------------------

--
-- 表的结构 `article_type`
--

DROP TABLE IF EXISTS `article_type`;
CREATE TABLE IF NOT EXISTS `article_type` (
  `type` varchar(60) NOT NULL,
  `time` datetime DEFAULT NULL,
  `isShow` tinyint(1) NOT NULL COMMENT '是否显示在侧边栏',
  PRIMARY KEY (`type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `article_type`
--

INSERT INTO `article_type` (`type`, `time`, `isShow`) VALUES
('React', '2021-11-12 01:32:34', 0),
('Vue', '2021-11-12 01:32:20', 0),
('测试添加类型', '2021-12-10 20:09:39', 1),
('萨', '2021-12-10 20:09:39', 0);

-- --------------------------------------------------------

--
-- 表的结构 `comment`
--

DROP TABLE IF EXISTS `comment`;
CREATE TABLE IF NOT EXISTS `comment` (
  `id` varchar(60) NOT NULL,
  `commentator` varchar(20) NOT NULL COMMENT '评论者',
  `superior` varchar(60) DEFAULT NULL COMMENT '评论的上级',
  `articleId` varchar(30) DEFAULT NULL COMMENT '评论在什么地方（文章/公共）',
  `content` text NOT NULL COMMENT '评论内容',
  `time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- --------------------------------------------------------

--
-- 表的结构 `github`
--

DROP TABLE IF EXISTS `github`;
CREATE TABLE IF NOT EXISTS `github` (
  `id` varchar(60) NOT NULL,
  `name` varchar(200) NOT NULL COMMENT '项目名称',
  `description` text NOT NULL COMMENT '项目介绍',
  `image` varchar(200) NOT NULL COMMENT '预览图片',
  `languages` varchar(200) NOT NULL COMMENT '使用什么语言编写的项目',
  `url` varchar(200) NOT NULL COMMENT '项目地址',
  `time` datetime NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `github`
--

INSERT INTO `github` (`id`, `name`, `description`, `image`, `languages`, `url`, `time`) VALUES
('6dbfe5284ce5a8583bf79855dd6c0b05', '胜多负少的', '是的分公司的', '04d717ec1d963db80b3c6ad4c8e88a80.webp', '的双方各', '法国红酒发1233456', '2022-02-13 20:53:50');

-- --------------------------------------------------------

--
-- 表的结构 `user`
--

DROP TABLE IF EXISTS `user`;
CREATE TABLE IF NOT EXISTS `user` (
  `email` varchar(60) CHARACTER SET latin1 NOT NULL COMMENT '用户邮箱',
  `password` varchar(40) CHARACTER SET latin1 NOT NULL COMMENT '用户密码',
  `GitHub` varchar(60) CHARACTER SET latin1 DEFAULT NULL COMMENT 'GitHub地址',
  PRIMARY KEY (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `user`
--

INSERT INTO `user` (`email`, `password`, `GitHub`) VALUES
('1974109227@qq.com', '96e79218965eb72c92a549dd5a330112', 'https://github.com/LRunLin');
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
